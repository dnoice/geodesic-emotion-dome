<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geodesic Emotion Dome - Simple Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        }
        
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
            transition: opacity 0.5s;
        }
        
        #loader.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 10px;
            z-index: 100;
            text-align: center;
        }
        
        .error {
            color: #ff6b6b;
            margin-top: 20px;
            padding: 10px;
            background: rgba(255, 0, 0, 0.1);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="loader">
        <h1>Loading Emotion Dome...</h1>
        <p>Initializing 3D environment</p>
        <div id="error-message"></div>
    </div>
    
    <div id="canvas-container"></div>
    
    <div class="info">
        <h2>Geodesic Emotion Dome</h2>
        <p>22 Emotions ‚Ä¢ 6 Categories</p>
        <p id="debug-info"></p>
    </div>
    
    <div class="controls">
        <p>üñ±Ô∏è Drag to rotate ‚Ä¢ üìú Scroll to zoom ‚Ä¢ üéØ Click nodes</p>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Debug info
        console.log('Starting Geodesic Emotion Dome - Simple Version');
        
        // Check if Three.js loaded
        if (typeof THREE === 'undefined') {
            document.getElementById('error-message').innerHTML = '<div class="error">Error: Three.js failed to load. Please check your internet connection.</div>';
            console.error('Three.js is not loaded!');
        } else {
            console.log('Three.js loaded successfully:', THREE.REVISION);
        }
        
        // Global variables
        let scene, camera, renderer;
        let emotionNodes = [];
        let connections = [];
        let raycaster, mouse;
        
        // Simple emotion data
        const emotions = [
            { name: 'Joy', color: 0xFFD700, connections: ['Love', 'Hope'] },
            { name: 'Love', color: 0xFF69B4, connections: ['Joy', 'Trust'] },
            { name: 'Hope', color: 0x00CED1, connections: ['Joy', 'Courage'] },
            { name: 'Trust', color: 0xC71585, connections: ['Love', 'Peace'] },
            { name: 'Peace', color: 0x20B2AA, connections: ['Trust', 'Acceptance'] },
            { name: 'Acceptance', color: 0x48D1CC, connections: ['Peace', 'Hope'] },
            { name: 'Courage', color: 0x006666, connections: ['Hope', 'Determination'] },
            { name: 'Determination', color: 0x008B8B, connections: ['Courage', 'Hope'] },
            { name: 'Sadness', color: 0x4169E1, connections: ['Grief', 'Compassion'] },
            { name: 'Grief', color: 0x191970, connections: ['Sadness', 'Anger'] },
            { name: 'Anger', color: 0xDC143C, connections: ['Grief', 'Fear'] },
            { name: 'Fear', color: 0x8B008B, connections: ['Anger', 'Anxiety'] },
            { name: 'Anxiety', color: 0x9932CC, connections: ['Fear', 'Overwhelm'] },
            { name: 'Overwhelm', color: 0x9370DB, connections: ['Anxiety', 'Sadness'] },
            { name: 'Compassion', color: 0xFF1493, connections: ['Love', 'Sadness'] },
            { name: 'Excitement', color: 0xFFA500, connections: ['Joy', 'Curiosity'] },
            { name: 'Curiosity', color: 0x5F9EA0, connections: ['Excitement', 'Hope'] },
            { name: 'Gratitude', color: 0xFFB347, connections: ['Joy', 'Love'] },
            { name: 'Frustration', color: 0xB22222, connections: ['Anger', 'Determination'] },
            { name: 'Jealousy', color: 0x8B0000, connections: ['Anger', 'Fear'] },
            { name: 'Loneliness', color: 0x6495ED, connections: ['Sadness', 'Fear'] },
            { name: 'Nostalgia', color: 0x4682B4, connections: ['Sadness', 'Joy'] }
        ];
        
        function init() {
            try {
                console.log('Initializing scene...');
                
                // Scene
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x0a0e27, 10, 50);
                
                // Camera
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.z = 15;
                
                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('canvas-container').appendChild(renderer.domElement);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const pointLight = new THREE.PointLight(0xffffff, 0.8);
                pointLight.position.set(10, 10, 10);
                scene.add(pointLight);
                
                // Create geodesic structure
                createGeodesicDome();
                
                // Mouse interaction
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Event listeners
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mouseup', onMouseUp);
                
                // Start animation
                animate();
                
                // Hide loader
                setTimeout(() => {
                    document.getElementById('loader').classList.add('hidden');
                }, 1000);
                
                // Update debug info
                document.getElementById('debug-info').textContent = `Nodes: ${emotionNodes.length} | FPS: 60`;
                
                console.log('Initialization complete!');
                
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('error-message').innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }
        
        function createGeodesicDome() {
            console.log('Creating geodesic dome...');
            
            // Create icosahedron geometry for positions
            const radius = 6;
            const geometry = new THREE.IcosahedronGeometry(radius, 1);
            const positions = geometry.attributes.position;
            
            // Create emotion nodes
            for (let i = 0; i < emotions.length && i < positions.count; i++) {
                const emotion = emotions[i];
                const x = positions.array[i * 3];
                const y = positions.array[i * 3 + 1];
                const z = positions.array[i * 3 + 2];
                
                // Create sphere
                const sphereGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const sphereMaterial = new THREE.MeshPhongMaterial({
                    color: emotion.color,
                    emissive: emotion.color,
                    emissiveIntensity: 0.3
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(x, y, z);
                sphere.userData = emotion;
                
                scene.add(sphere);
                emotionNodes.push(sphere);
            }
            
            // Create connections
            emotionNodes.forEach(node => {
                const emotion = node.userData;
                emotion.connections.forEach(targetName => {
                    const targetNode = emotionNodes.find(n => n.userData.name === targetName);
                    if (targetNode) {
                        const points = [];
                        points.push(node.position);
                        points.push(targetNode.position);
                        
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: 0xffffff,
                            opacity: 0.2,
                            transparent: true
                        });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        scene.add(line);
                        connections.push(line);
                    }
                });
            });
            
            console.log(`Created ${emotionNodes.length} nodes and ${connections.length} connections`);
        }
        
        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };
                
                scene.rotation.y += deltaMove.x * 0.005;
                scene.rotation.x += deltaMove.y * 0.005;
            }
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        function onMouseDown(event) {
            isDragging = true;
        }
        
        function onMouseUp(event) {
            isDragging = false;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle scroll for zoom
        window.addEventListener('wheel', (event) => {
            camera.position.z += event.deltaY * 0.01;
            camera.position.z = Math.max(5, Math.min(25, camera.position.z));
        });
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Auto-rotate when not dragging
            if (!isDragging) {
                scene.rotation.y += 0.002;
            }
            
            // Animate nodes
            const time = Date.now() * 0.001;
            emotionNodes.forEach((node, index) => {
                node.scale.setScalar(1 + Math.sin(time + index) * 0.05);
            });
            
            renderer.render(scene, camera);
        }
        
        // Check WebGL support
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext && 
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch(e) {
                return false;
            }
        }
        
        // Start the app
        if (checkWebGLSupport()) {
            init();
        } else {
            document.getElementById('error-message').innerHTML = '<div class="error">WebGL is not supported in your browser. Please use a modern browser.</div>';
        }
    </script>
</body>
</html>
